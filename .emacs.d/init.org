#+title: emacs configuration
#+property: header-args:emacs-lisp :tangle ./init.el :mkdirp yes
#+options: num:nil
#+html_head <link rel="stylesheet" type"text/css" href=""/>
* emacs install
#+begin_src shell
  sudo apt update
  sudo apt upgrade -y && sudo apt autoremove -y
  sudo apt-get install libutils
  sudo apt-get install ubuntu-desktop
  sudo apt-get install indicator-appmenu-tools
  ./configure --with-native-compilation --with-mailutils
  sudo apt install libtool-bin #vterm설치용
  sudo apt install compton  #스크롤 부드럽게
  sudo apt install feh #백그라운드 설정
  sudo apt install arandr #해상도 조절
  sudo apt install scrot brightnessctl playerctl #스크린샷, 밝기컨트롤, 오디오 컨트롤
  sudo apt install blueman pasystray pavucontrol #bt컨트롤
  sudo apt install slock xss-lock #화면잠금
  sudo apt install xsel #클립보드 복사 $xsel --clipboard < sadf.txt  반대는 > text.txt
  sudo apt install autorandr #display연결등의 변경을 감지
  sudo apt-get install nabi
  im-config -s nabi
  emacs -q -nw #cmd로 실행
#+end_src
.xprofile .xinitrc.exwm
#+begin_src shell
export XIM=nabi
export XIM_ARGS=
export XIM_PROGRAM="nabi"
export XMODIFIERS="@im=nabi"
export ENCORE_IMF_MODULE=xim
export GTK_IM_MODULE=xim
export GTK_TM_MODULE=xim
export GTK3_IM_MODULE=xim
export QT_IM_MODULE=xim
export QT_TM_MODULE=xim
export QT4_IM_MODULE=xim
export QT5_IM_MODULE=xim
export CLUTTER_IM_MODULE=xim
LANG=ko_KR.UTF8 nabi &
#+end_src

* basic shortcut
** 자주 쓰는 단축키
|----------------------+----------------------------|
| 명령어               | 단축키                     |
|----------------------+----------------------------|
| 텍스트 크기조절      | c-x c-0 누른 후 + 하거나 - |
|----------------------+----------------------------|
| 한줄실행             | c-x c-e                    |
|----------------------+----------------------------|
| 바로 실행            | m-: eval                   |
|----------------------+----------------------------|
| 명령어 찾기          | m-x                        |
|----------------------+----------------------------|
| 현재 단어 하이라이트 | m-s h .                    |
|----------------------+----------------------------|
| 정규식 하이라이트    | m-s h r                    |
|----------------------+----------------------------|
| 하이라이트 삭제      | m-s h u                    |
|----------------------+----------------------------|
| 파일 북마크 추가     | c-x r m                    |
|----------------------+----------------------------|
| bookmark jump        | c-x r b                    |
|----------------------+----------------------------|
| list bookmark        | c-x r l                    |
|----------------------+----------------------------|
| emacs 종료           | C-x C-c                    |
|----------------------+----------------------------|
| org export           | C-c C-e h h                |
|----------------------+----------------------------|
| async shell          | M-&                        |
|----------------------+----------------------------|
| async shell          | win-&                      |
|----------------------+----------------------------|
| focus switch buff    | C-x w number               |
|----------------------+----------------------------|
| Org show images      | C-c C-x C-v                |
|----------------------+----------------------------|
| Symbol rename        | M-s . -> C-M-% -> !        |
|----------------------+----------------------------|
| Evil-emacs-state     | C-z                        |
|----------------------+----------------------------|
| timer                | C-c C-x ;                  |
|----------------------+----------------------------|
  rename-file
  M-x check-parens : init.el디버깅 괄호 틀린지
  describe-bindings =C-h b=
  describe-variable =C-h v=
  describe-function =C-h f=
  M-x proced =x= send signal
  (start-process-shell-command "tool" nil "vim ~/test.txt") : 비동기로 출력없이 실행

** dired 사용법
- =C-x d= 가 단축키
  =dired-listing-switches= : -al 기본이 ls -al 처럼 보이니 이걸 바꾸면 됨
  =C-x C-j= 바로 현재창에 dired 띄우기
  ^ : 상위 디렉토리로 이동
  J : 파일이름 검색해서 이동
  RET : 파일이나 디렉토리 열기
  M-RET : 다른 창에서 열기 S-RET 는 열고 포커스는 이동안함
  go : 프리뷰 모드로 esc하면 창 닫고 돌아감
  q : dired buffer bury
  gy : file type
  =gr : buffer refresh=
  M : chmod
  O : chown
  gG : change the group
  L : load an emacs lisp into emacs
  =C : copy=
  = : dired diff
  =+ : create a directory=
  =D : delete=
  =R : rename / move=
  C-x C-q : vim 모드로 여러파일 이름 변화후 Z Z 하면 저장됨, 
  S : symlinc
  H : hardlink
  Z : do compress/decompress tar.gz
  c : compress selection to a specific file
  X : do shell command =!=
  =m : mark=
  =u : unmark=
  U : unmark all
  t : invert mark
  * : options
  */ : select directories
  %m : regex mark
  & : dired-do-async-shell-command
  C-ret : open with external
  
* basic configuration
** clean up emacs user interface, make it minimal.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (setq inhibit-startup-message t)
 
  ;(unless dw/is-termux
  (scroll-bar-mode -1)        ; disable visible scrollbar
  (tool-bar-mode -1)          ; disable the toolbar
  (tooltip-mode -1)           ; disable tooltips
  (set-fringe-mode 10)       ; give some breathing room
 
  (menu-bar-mode -1)            ; disable the menu bar
 
  ;; set up the visible bell
  (setq visible-bell nil)
  (setq ring-bell-function 'ignore)
 
  ;; adjust font size 
  (defvar efs/default-font-size 180) ; macos
  ;(defvar efs/default-font-size 135) ;gumi linux
 
  ;; set frame transparency
  (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
  (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (if (eq system-type 'darwin)
      (setenv "LIBRARY_PATH" "/opt/homebrew/opt/gcc/lib/gcc/11:/opt/homebrew/opt/libgccjit/lib/gcc/11:/opt/homebrew/opt/gcc/lib/gcc/11/gc\
 /aarch64-apple-darwin21/11:/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib"))
  (if (eq system-type 'darwin)
      (setenv "LD_lIBRARY_PATH" "/opt/homebrew/opt/gcc/lib/gcc/11:/opt/homebrew/opt/libgccjit/lib/gcc/11:/opt/homebrew/opt/gcc/lib/gcc/11/gc\
 /aarch64-apple-darwin21/11:/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib"))
  (if (eq system-type 'darwin)
       (add-to-list 'exec-path "/opt/homebrew/bin"))
#+end_src

 - auto-package-update-now #이걸로 바로 가능함
#+begin_src emacs-lisp
(use-package auto-package-update
  :custom
  (auto-package-update-interval 7)
  (auto-package-update-prompt-before-update t)
  (auto-package-update-hide-results t)
  :config
  (auto-package-update-maybe)
  (auto-package-update-at-time "09:00"))
#+end_src
** package setup

- use-package는
  ensure t은 package가 로컬에 없을때 다운로드 하게함
  init은 패키지 로드 전 실행랄 코드
  command 는 autoload명령으로 init과 config사이 동작
  config는 패키지 로드 후 실행할 내용
  bind는 m-x describe-personal-keybinding 에 키 바인딩 적재 시킴
  이것과 동일하게 일을 시키는건 아래와 같음
   init
   (bind-key "c-." 'ace-jumbp-mode))
  bind-keymap은 비슷한데 그 패키지에 정의된 keymap만 사용가능

#+begin_src emacs-lisp
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))
  ;; fix an issue accessing the elpa archive in termux
  ;(when dw/is-termux
  ;  (setq gnutls-algorithm-priority "normal:-vers-tls1.3"))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; initialize use-package on non-linux platforms
  (unless (package-installed-p 'use-package)
     (package-install 'use-package))
  (require 'use-package)

  ;; uncomment this to get a reading on packages that get loaded at startup
  ;;(setq use-package-verbose t)

  ;; on non-guix systems, "ensure" packages by default
  (setq use-package-always-ensure t)
#+end_src

** Keep folders Clean
파일을 수정 후 저장하면 최초 버퍼 열었을때 파일을 ~를 붙여서 백업하기
https://github.com/emacscollective/no-littering
#+begin_src emacs-lisp
  ;.emacs.d에다가 tmp만들어서 거기 다 백업
  ;(setq backup-directory-alist '(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
  ;모든 백업을 끌때
  (setq make-backup-files nil)
  
  ;https://github.com/emacscollective/no-littering
  ;패키지들이 잡다하게 만드는 파일들의 위치를 정리해줌
  (use-package no-littering)
#+end_src

#+RESULTS:

** Auto save move
저장안한 파일에 #붙어 자동 저장되는것
http://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Save-Files.html#Auto-Save-Files
#+begin_src emacs-lisp
  ; 폴더 없으면 생기게 하고
  (make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)
  
  (setq auto-save-list-file-prefix (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory)
        auto-save-file-name-transforms `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))
#+end_src

** Lock Files
파일을 열고 수정한 상태로 있으면 lock을 함  .#Emacs.org처럼
#+begin_src emacs-lisp
;(setq create-lockfiles nil)
#+end_src


** custom packages

#+begin_src emacs-lisp
  (custom-set-variables
   '(package-selected-packages
     '(evil-magit magit ag rg ripgrep hydra evil-collection undo-tree evil general all-the-icons-dired doom-modeline marginalia vertico command-log-mode use-package)))
  (custom-set-faces
   )
#+end_src

* interface settings
** set font 

#+begin_src emacs-lisp
(defun efs/set-font-faces ()
  (message "Setting faces!")
  (if (eq system-type 'darwin)
     (set-face-attribute 'default nil :family "d2coding" :height 175)) ;macbook
  (if (eq system-type 'gnu/linux)
     (set-face-attribute 'default nil :family "d2coding" :height 135)) ;linux
  (setq default-input-method "korean-hangul")
  (set-fontset-font t 'hangul (font-spec :name "d2coding"))
  (global-set-key (kbd "S-SPC") 'toggle-input-method))

(if (daemonp)
    (add-hook 'after-make-frame-functions
              (lambda (frame)
                (setq doom-modeline-icon t)
                (with-selected-frame frame
                  (efs/set-font-faces))))
    (efs/set-font-faces))
#+end_src

** line number

#+begin_src emacs-lisp
  (column-number-mode) 
  (global-display-line-numbers-mode t) ;t 는 시작시 묻지말고 셋하라는 의미
  (setq display-line-numbers-type 'relative)
  ;; enable line numbers for some modes
  (dolist (mode '(term-mode-hook
                  eshell-mode-hook
                  vterm-mode-hook
                  treemacs-mode-hook
                  shell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
  (dolist (mode '(text-mode-hook
                  prog-mode-hook
                  conf-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 1))))
#+end_src

** mode line

#+begin_src emacs-lisp
  (use-package doom-modeline)
  (doom-modeline-mode 1)

  (use-package all-the-icons
    :if (display-graphic-p)
    :commands all-the-icons-install-fonts
    :init
    (unless (find-font (font-spec :name "all-the-icons"))
      (all-the-icons-install-fonts t)))


  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 15))
#+end_src

** Theme

#+begin_src emacs-lisp
  (use-package doom-themes)
  (load-theme 'doom-gruvbox 1)
#+end_src

** Delimiter

#+begin_src emacs-lisp
  (use-package  rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Helpful functions

#+begin_src emacs-lisp
  (use-package  which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.5))

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . helpful-function)
    ([remap describe-symbol] . helpful-symbol)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-command] . helpful-command)
    ([remap describe-key] . helpful-key))

  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

** Key settings

#+begin_src emacs-lisp
(use-package general
  :config
  (general-evil-setup t)
  (general-create-definer my/leader-keys
    :keymaps '(normal insert visual emacs)
    ;:prefix "C-M"
    :global-prefix "C-SPC"))
  ;(my/leader-keys
  ; "ts" '(load-theme :which-key "choose theme")))

(use-package undo-tree
  :init
  (setq undo-tree-auto-save-history nil)
  (global-undo-tree-mode 1))
#+end_src

** Evil Mode

#+begin_src emacs-lisp
  (use-package evil
    ;; Pre-load configuration
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    (setq evil-respect-visual-line-mode t)
    (setq evil-undo-system 'undo-tree)
  
    :config
    ;; Activate the Evil
    (evil-mode 1)
  
    ;; Set Emacs state modes
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
  
    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  
    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
  ;ysiw 한담에 ' 하면 해당단어 ''로 서라운드
  ;ds 는 지우기
  ;cs 는 바꾸기
  ;선택한담에 S하면 선택한부분 surround
  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))
  (use-package evil-visualstar
    :ensure t
    :config
    (global-evil-visualstar-mode t))
  
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
  
  ;evil에서 심볼단위 검색 가능하도록 언더바 있으면 선택 안되던 문제 해결
  (with-eval-after-load 'evil
    (defalias #'forward-evil-word #'forward-evil-symbol)
    ;; make evil-search-word look for symbol rather than word boundaries
    (setq-default evil-symbol-word-search t))
  
  ;선택 영역 단어 변경 vim스타일
  (defun evilcvn-change-symbol-in-defun ()
    "use string replacing UI in evil-mode to replace the symbol under cursor"
    (interactive)
    (let ((old (thing-at-point 'symbol)))
      (evil-ex (concat "%s/" (if (= 0 (length old)) "" "") old (if (= 0 (length old)) "" "/"))))
    )
  (global-set-key (kbd "M-s M-s") 'evilcvn-change-symbol-in-defun)
#+end_src

#+RESULTS:
| (lambda nil (setq evil-input-method nil)) | evil-maybe-expand-abbrev | evil-stop-track-last-insertion | evil-cleanup-insert-state | doom-modeline-update-buffer-file-name |

  - =dired-listing-switches:= try =-agho --group-directories-first= 디렉토리 후 파일 보이게 하는것
  - dired single : dired buffer를 하나로 관리  
  - 특정 확장자를 emacs가 아닌 다른 프로그램으로 열어서 exwm이 열게도 가능\
  - mupdf 관련세팅 https://www.romanzolatarev.com/xdg-mime.html

#+begin_src emacs-lisp
  ;mac built in ls does not support group-directories-first
  ;so brew install coreutils first
  (if (eq system-type 'darwin)
      (setq insert-directory-program "gls" dired-use-ls-dired t))
  (use-package dired-single)
  (use-package dired
    :ensure nil ;use-package가 install 안하게 함.
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom ((dired-listing-switches "-al --group-directories-first"))
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))
  (use-package all-the-icons-dired
    :if (display-graphic-p)
    :hook (dired-mode . all-the-icons-dired-mode))
  ;png파일은 feh라는 툴로 열고...
  (use-package dired-open
    :config
    (setq dired-open-extensions '(("png" . "feh")
                                  ("mkv" . "mpv"))))
  ;hide dot files
  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))
  (defun mu-open-in-external-app ()
    "Open the file where point is or the marked files in Dired in external
    app. The app is chosen from your OS's preference."
    (interactive)
    (let* ((file-list
	    (dired-get-marked-files)))
     (mapc
      (lambda (file-path)
       (let ((process-connection-type nil))
	(start-process "" nil "xdg-open" file-path))) file-list)))
  (define-key dired-mode-map (kbd "C-<return>") #'mu-open-in-external-app)
#+end_src

** easy motion
#+begin_src emacs-lisp

    ;;easymotion C-'를 트리거로 설정
    (use-package avy)
    (evil-define-key '(normal visual) 'global
     "," #'avy-goto-char-2)
#+end_src

** evil mc 멀티커서
#+begin_src emacs-lisp
 ;;evil-multiedit 힐스너 버전
 ;(use-package evil-multiedit)
 ;(evil-multiedit-default-keybinds)
 ;(use-package evil-mc)
 ;(global-evil-mc-mode 1)
 ;; evil-mc
 ;(evil-define-key '(normal visual) 'global
 ;  "gzm" #'evil-mc-make-all-cursors
 ;  "gzu" #'evil-mc-undo-all-cursors
 ;  "gzz" #'+evil/mc-toggle-cursors
 ;  "gzc" #'+evil/mc-make-cursor-here
 ;  "gzn" #'evil-mc-make-and-goto-next-cursor
 ;  "gzp" #'evil-mc-make-and-goto-prev-cursor
 ;  "gzN" #'evil-mc-make-and-goto-last-cursor
 ;  "gzP" #'evil-mc-make-and-goto-first-cursor)
 ; (with-eval-after-load 'evil-mc
 ;   (evil-define-key '(normal visual) evil-mc-key-map
 ;     (kbd "C-n") #'evil-mc-make-and-goto-next-cursor
 ;     (kbd "C-N") #'evil-mc-make-and-goto-last-cursor
 ;     (kbd "C-p") #'evil-mc-make-and-goto-prev-cursor
 ;     (kbd "C-P") #'evil-mc-make-and-goto-first-cursor))
#+end_src

* Completion System
** Vertico

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("M-h" . backward-kill-word))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))

  (use-package savehist
    :init
    (savehist-mode))

  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))

#+end_src

* Coding Environment
** Projectile

- .projectile파일을 폴더에 넣으면 프로젝트로 인식함 .git이 있어도 됨
- 모든 프로젝타일 키를 =C-c p= 로 트리거하겠다
- =C-c p f= 이후 =M-o= 하면 메뉴가 많아지는데 스크롤 방법을 모름.
- counsel-projectil-rg =C-c p s r=
- projectile-discover-projects-in-search-path
- setq projectile-discover-projects-in-search-path '("~/workspace" "/media/test"))


#+begin_src emacs-lisp
  ;https://youtu.be/INTu30BHZGk
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map) ;;모든 프로젝타일 키를 C-c p 로 트리거하겠다
    :init
    (when (file-directory-p "~/workspace")
      (setq projectile-project-search-path '("~/workspace")))
    (setq projectile-switch-project-action #'projectile-dired)
    :bind
    ("C-s" . projectile-ripgrep))
  
  ;C-c p f이후 M-o하면 메뉴가 많아지는데 스크롤 방법을 모름.
  ;counsel-projectil-rg = c-p-s-r
  (use-package counsel-projectile
    :config (counsel-projectile-mode))
  
#+end_src

** Commenting
- M-; 가 기본 emacs comment 설정인데 선택 없을시 좀 이상하게 동작함
- 그래서 요거 써서 =M-/= 로 하면 됨


#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
  :bind ("M-/" . evilnc-comment-or-uncomment-lines))
#+end_src

** Language Modes
*** c-mode
- 컴파일 C-c p P : g++ -g -o hello hello.cpp && ./hello
#+begin_src emacs-lisp
  (use-package c-mode
    :ensure nil
    :hook (c-mode . lsp-deferred) ;c mode켤때 lsp모드 켬
  )
  (use-package c++-mode
    :ensure nil
    :hook (c-mode . lsp-deferred) ;cpp mode켤때 lsp모드 켬
  )
#+end_src
*** python-mode

- ensure nil의 의미는 use-package가 python-mode를 인스톨 하지 않게 함.
- python실행이 python3을 쓰게 함
- hook 으로 python-mode에 들어오면 lsp mode사용하게 함
- C-c p P : pytest -s -v
- C-c p P : pytest -s -v unittests/test_get_tankdump.py
- C-c p P : pytest -s -v -k test_function_name
- C-c p P : cd utopia_preprocess&&pytest -s -v -k test_function_name
  -s : print문 보이게 함
  -v : 더 디테일한 정보
  -k : test_뒤에 있는 이름 기반으로 테스트
  -x : fail시 멈춤


#+begin_src emacs-lisp
  (use-package python-mode
    :ensure nil
    ;:hook (python-mode . lsp-deferred) ;python mode켤때 lsp모드 켬
    :custom
    (python-shell-interpreter "python3")
    (dap-python-excutable "python3")
    (dap-python-debugger 'debugpy)
    :config
    (require 'dap-python)
  )
  ;lsp mode to pyright
  (use-package lsp-pyright
  :ensure t
  :hook (python-mode . (lambda ()
                          (require 'lsp-pyright)
                          (lsp))))

  ;Feel free to throuw your wown personal keybindings here
  ;(map! :leader :desc "Blacken Buffer" "m b b" #'python-black-buffer)
  ;(map! :leader :desc "Blacken Region" "m b r" #'python-black-region)
  ;(map! :leader :desc "Blacken Statement" "m b s" #'python-black-statement)
  (use-package python-black
    :ensure t
    :after python
    :hook (python-mode . python-black-on-save-mode-enable-dwim))
#+end_src

#+RESULTS:
| evil-collection-python-set-evil-shift-width | lsp-deferred | doom-modeline-env-setup-python |

Commands:
- Interactive Python shell: =M-x run-python= (C-c C-p or g z in evil-mode)
- python-shell-send-region =C-c C-r=
  : 다른 버퍼에 run-python실행하고, 이 버퍼에서 영역 산택후 send-region하면 python interpreter에서 실행됨
- python-shell-send-buffer =C-c C-c=
  : 버퍼내용을 통채로 넘겨서 실행함
- python-shell-send-file =C-c C-l=
  : 파일내용을 통채로 넘겨서 실행함
**** python virtual env
- pyvenv-activate 요걸로 파일 열기 전에 venv 선택할 수 있음
- pyvenv-deactivate
- .dir-locals.el
  ((nil . ((pyvenv-activate . "~/.venv"))))
  : eval: (getenv "VIRTUAL_ENV") 하면 설정된 path가 보임

#+begin_src emacs-lisp
  (use-package pyvenv
  :config
  (pyvenv-mode 1))
#+end_src

*** TypeScript
#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\\.ts\\'"
  :hook (typescript-mode . lsp-deferred)
  :config
  (setq typescript-indent-level 2))
#+end_src

*** Rope
- traad3 is a python refactoring server
#+begin_src emacs-lisp
  (use-package traad)
  (setq traad-environment-name "traad3")
  (setq venv-location "/home/hongiee/python3env/")
  ;(traad-install-server)
#+end_src

** lsp-mode
- yas-new-snippet
 : ./.emacs.d/snippet/org-mode/code
- M-x yas-new-snippet 하고 끝날때는 C-x C-s 로 저장
  
 $0 이 마지막 위치
 $1{:hint}

 지정된 mode에서 단축어 누르고 tab누르면 실행됨
 <code-emacs 하고 탭
 <code-python 하고 탭
 <code-cpp 하고 탭

 
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-snippet-dirs'("~/.emacs.d/snippets"))
    (yas-global-mode 1))
#+end_src
- 기본 키는 window - l 같은 키여서 =C-c l= 로 바꿈
- completion-at-point 를 잘 사용하자 C-down + ivy


#+begin_src emacs-lisp
  (defun efs/lsp-mode-setup()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode)) ;위에 경로 보여주기

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (lsp-mode . efs/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")
    (setq lsp-idle-delay 0.3)
    :config
    (lsp-enable-which-key-integration t))

#+end_src

*** flymake 
- flymake-show-diagnostics-buffer : error, warning진단을 보여줌
  flycheck-list-errors ; flymake 동일
  #+begin_src emacs-lisp
(use-package flymake-diagnostic-at-point
  ;:after flymake
  :config
  (add-hook 'flymake-mode-hook #'flymake-diagnostic-at-point-mode))
;(use-package flycheck
;  :ensure t
;  :init (global-flycheck-mode))

  #+end_src

  
*** lsp with python-mode

- lsp-find-defenition =C-c l g g=
- lsp-find-reference =C-c l g r= C-j, C-k로 위아래
- lsp-rename =C-c l r r=
- lsp-format-buffer =C-c l = == ;default = flake8
- lsp-format-region =C-c l = r=
- python lsp-mode
  =M-x eshell=
#+begin_src shell
  pip install 'python-lsp-server[all]'
  pip install 'pyright'
  pip install 'pytest'
  pip install 'debugpy'
#+end_src
- projectile-test-project "pytest" 라는 명령으로 테스트 하도록
  그 버퍼에서 g r 누르면 다시 테스트함(evil mode인경우)
  다른 버퍼면 M-x recompile 커맨드 누름 됨

*** lsp with typescript

#+begin_src shell
npm i -g typescript-language-server; npm i -g typescript
#+end_src


*** Company Mode

- company mode는 completion-at-point보다 보기 좋게 만들어줌
- tab이 선택을 의미하게 만듬. 글자가 없을때 tab은 인덴트를 의미하게도 만듬
- 최소 1자이상 그리고 바로 팝업 발생하게 만듬
- company-mode시작하면 company-box-mode도 시작하게 훅을 해둠

#+begin_src emacs-lisp
(use-package company
  :after lsp-mode
  :hook (lsp-mode . company-mode)
  :bind (:map company-active-map
         ("<tab>" . company-complete-selection))
        (:map lsp-mode-map
         ("<tab>" . company-indent-or-complete-common))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.5))

(use-package company-box
  :hook (company-mode . company-box-mode))
#+end_src

*** lsp-ui

- 조금더 IDE처럼 만들어줌 doc string을 보여주기도 하고
- https://github.com/emacs-lsp/lsp-ui
- lsp-ui-doc-focus-frame 하면 그곳에 포커스가 가고 하면 빠져나옴
- lsp-ui-doc-unfocus-frame 하면 빠져나옴

- lsp-ui-peek-find-defenition (C-c l G g)
- lsp-ui-peek-find-reference (C-c l G r) C-n, C-p로 위아래
  단점은 버퍼를 많이 열어둠

#+begin_src emacs-lisp
(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode))
;:custom
;(lsp-ui-doc-position 'bottom))
#+end_src

***  lsp treemacs
- nerd tree같이 보여줌
- lsp-treemacs-symbols : symbol들을 nerd tree처럼 보여줌
- lsp-treemacs-references
- treemacs
#+begin_src emacs-lisp
(use-package lsp-treemacs
  :after lsp)
(use-package treemacs-projectile)
#+end_src

*** pytest
- pytest를 우선 설치
- M-x =projectile-test-project=
  : 이거 입력하면 어떤 테스트 커맨드 할지 물어봄(기본값은 projectile-project-test-cmd로 변경가능)
  : python -m unittest discover
  : 끝나고 해당버퍼에서 r누르면(evil-mode)일때, 다른 버파일때는 M-x recompile하면 됨.
- 묻지않고 테스트 하게끔 하는법
  : add-dir-local-variable -> python-mode -> projectile-project-test-cmd -> "pytest" 이렇게 하면 해당 디렉토리 파이썬 파일 열때 저 명령어 쓸지  물어봄 Envl: (setq compilation-read-command nil) 까지 해주면 test시 묻지않고 실행
 
*** lsp ivy
- symbol 을 입력해서 검색하는것 ;lsp server가 지원할 경우
  lsp-ivy-workspace-symbol
  #+begin_src emacs-lisp
  (use-package lsp-ivy)
  #+end_src

** dap-mode
- Reference : https://emacs-lsp.github.io/dap-mode/page/confiruration/

#+begin_src emacs-lisp
  (use-package dap-mode
    :ensure t
    ;기존에는 dap-auto-configure-feature변수에 sessions locals breakpoints expressions controls tooltip다보임
    ;그 중 몇개만 보려면 아래처럼 set
    ;:custom
    ;(dap-auto-configure-features '(sessions locals tooltip))
  
    ;breakpoint걸릴때마다 hydra띄우기
    :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra))))
#+end_src

*** python debugging
#+begin_src shell
  pip install debugpy
#+end_src

#+begin_src emacs-lisp
  ;요거 python-mode에 추가함
  ;(dap-python-debugger 'debugpy)
#+end_src
- dap-debug : 하면  Run file 이나 pytest등 실행하는데 debug mode기반으로 pytest도 가능 브레이크 포인트 걸고
- dap-debug-edit-template : 하면 dap-debug시 뜨는 것 편집 가능
  #+begin_src shell
(dap-register-debug-template
  "Python :: Run Pytest (gallery_dl)"
  (list :type "python"
	:cwd "/home/hongiee/workspace/gallery_dl"
	:module "pytest"
	:request "launch"
	:name "Python :: Run pytest (gallery_dl)"))
  #+end_src

*** BASIC
- dap-debug : 디버그 실행 시작
- dap-next : step over
- dap-continue : continue
- dap-breakpoint-toggle : break point걸기
- dap-debug-last : 디버그 실행 재시작
- dap-switch-stack-frame : call stack에서 어디로 점프할지
- dap-disconnect : stop 디버깅
- dap-debug-restart : stop하고 바로 start한 효과
- dap-debug-recent : 최신 디버그 컨피그로 시작
- dap-ui-breakpoints : breakpoint 보여줌
- dap-ui-locals : locals 보여줌
- dap-ui-sessions : 현재 active인 디버그 세션 보여줌 : C-z로 evil에서 빠져나온 후 S-d로 세션 삭제 가능
- dap-debug-edit-template : 언어마다 템플릿 정할수 있는데 정한걸 이걸로 선택함
- dap-register-debug-template : 요걸로 템플릿을 정함 

- 아래 코드를 github에 debug.el같은데 같이 올리는것도 방법 그후 C-x C-e 로 eval시킬수 있음
- 상세 옵션은 vscode doc for debugger에서 볼 수 있음
#+begin_src emacs-lisp
;(dap-register-debug-template "My App"
;  (list :type "python"
;        :args "-i"
;        :cwd nil ; project root 설정
;        :env '(("DEBUG" . "1"))
;        :target-module (expand-file-name "~/src/myapp/.env/bin/myapp")
;        :request "launch"
;        :name "My App"))
;(dap-register-debug-template "Unit Test python"
;  (list :type "python"
;        :args "-i"
;        :cwd nil ; project root 설정
;        :env '(("DEBUG" . "1"))
;        :target-module (expand-file-name "~/src/myapp/.env/bin/myapp")
;        :request "launch"
;        :name "My App"))
#+end_src

*** BreakPoint : 언어마다 지원하는게 다름
- dap-breakpoint-toggle : breakpoint 만들기
- dap-breakpoint-delete-all : breakpoint 전체 삭제
- dap-breakpoint-condition : conditional breakpoint toggle로 브레이크 포인트 건 후 컨디션 걸기
- dap-breakpoint-hit-conditions : hit conditions, number of hits before breakpoint stops 그 자리에 몇번 지나갔는지
- dap-breakpoint-log-message : 해당 breakpoint에서 멈추지 않고 정한 로그 출력 {}사용
- dap-ui-breakpoints-list : show breakpoint panel 브레이크 포인트 건것들 보여주기
- dap-ui-repl : 어딘가 break point걸고 멈춘다음.>> a 입력시 해당 변수 값 볼 수 있음
*** Hydra
- dap-hydra : 단축키로 step등 쉽게하기
#+begin_src emacs-lisp
;  breakpoint걸릴때마다 hydra띄우기
;  :hook (dap-stopped . (lambda (arg) (call-interactively #'dap-hydra))))
#+end_src
*** Expressions
- dap-ui-expressions-add : i 처럼 특정 변수 보는 watch창
- dap-ui-expressions-remove : 삭제
*** REPL
- dap-ui-repl : 해당 언어에서 간단한 코드 실행 함수실행, 변수값 보기 바꾸기 i+5
*** Tooltips
- dap-tooltip-mode : turns it on 변수에 마우스 올리면 변수값등이 pop up발생하는것 등
- dap-tooltip-at-point : show the value at the current point 현재 위치 팝업을 강제로 띄우는 방식
*** load vscode debug config
- dap-debug 실행할때 vscode debug config도 동작함

** magit
- git checkout -t origin/저장소 (원격 저장소 브랜치를 내 로컬에 생성 후 땡길시)
- git checkout -b 내저장소이름 원격저장소이름(새로운 브랜치명으로 땡길때)
- M-x magit-clone 하고 주소 gl:users/reponame 하고 경로
- M-x magit-submodule-add
- C-x g -> magit-status로 바인딩 되어 있음
  - q로 끄고
  - g로 리프레시
  - s는 stage함
  - u는 unstage함
  - M-n, M-p 섹션 내에서 이전 다음으로 커서 이동
  - ^ 키는 해당 섹션의 상위로 커서 이동
  - c는 commit이고 여기서 C-c C-c하면 커밋 실행
    ce(extend)는 이전 커밋에 메시지 없이 내용만 추가
    ca(amend)는 이전 커밋에 amend하는데 메시지 수정
    cw(reward)는 메시지만 수정 (마지막 커밋메시지만 수정 가능)
  - 몇번 이전 git log에 커밋하는건 rebase를 이용해서 수정함
    cF(instant Fixup) 한담에 현재 stage수정을 어느 commit에 넣을지 선택하고 C-c C-c하면 됨. (나가는건 C-c C-k)
  - branch관련
    b - s - 새로운 브랜치 이름 (spin off) : upstream에 없는 commit들을 새로운 branch로 이동 하면서 생성 및 master는 이전으로 돌림
    b - b (checkout)
  - Push
    P - p : 동일 이름의 브랜치에 push
    P - -f - p : -f를 하면 flag가 set 됨
  - Pull
    F - p : 동일 이름의 브랜치에서 pull
    F - u : upstream에서 땡겨오기 (upstream에서 땡긴다던가 origin/master)
    F - e : 다른 브랜치에서 땡겨오기 (upstream에서 땡긴다던가 origin/master)
    F - r : 현재 브랜치 설정을 merge가 아닌 rebase로 (pull할때 merge하지 않고 rebase하도록)
	    그 다음에 땡기면 rebase를 하게됨. conflict는 수정후 r하면 지속 rebase하고 a하면 abort로 최초 상태로 돌아감
  - Fetch
    f - p : 동일 이름의 브랜치에서 fetch
    f - u : upstream에서 땡겨오기 (upstream에서 땡긴다던가 origin/master)
    f - e : 다른 브랜치에서 땡겨오기 (upstream에서 땡긴다던가 origin/master)
    f - a : all remote에서 땡겨오기
  - stash
    z - z : 로컬 수정(both stage, unstage)을 저장하고 remote를 pull하는 용도.
    z - a (apply): stash내용을 로콜로 돌리면서 stash는 유지
    z - p (pop): stash내용을 로컬로 돌리면서 stash기록을 지움
  - discard
    x - y :마지막에 했던 수정 돌리기 (evil써야 x이고 원래는 k)
	   unstage 에 있는 수정내용 되돌리기
	   untrack에 있는 파일 지우기
  - .gitignore에 추가
    i - t : untrack에 있는 파일 .gitignore에 추가할때
    i - s : untrack에 있는 파일 subdirectory .gitignore에 추가할때
    i - p : untrack에 있는 파일 .git/info/exclude 에 추가할때 (private한 gitignore)
  - rebase관련
    commit history로 가서 r - i rebase로 M-k M-j로 이동 spin-off로 합치기 squash로 합치기 등 가능 d는 지우기

#+begin_src emacs-lisp
  (use-package magit
    :ensure t)
#+end_src

- https://github.com/justbur/emacs-vdiff-magit
  
#+begin_src emacs-lisp
  (use-package vdiff-magit
    :ensure t)
  (require 'vdiff-magit)
  (require 'vdiff)
  (define-key magit-mode-map "e" 'vdiff-magit-dwim)
  (define-key magit-mode-map "E" 'vdiff-magit)
  (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
  (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
  (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
  (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit)
#+end_src

* File/Dir Local Valiables
Run =M-x normal-mode= to active
특정 파일/디렉토리에 대한 세팅
Two forms:
#+begin_src emacs-lisp
;; -*- mode: emacs-lisp; tab-width: 8; -*-
#+end_src

#+begin_src emacs-lisp
  
  ;; Local Variables:
  ;; mode: emacs-lisp
  ;; tab-width: 8
  ;; eval; (eldoc-mode 0)
  ;; End:
  
#+end_src

Comands:
- =add-dir-local-variable= : Add local variable to the files in the dir
  파일 모드에 따라 file local variable을 다르게 설정가능
  org-mode magit-diff-mode등
  설정하면 .dir-locals.el파일에 모드별설정이 저장이 됨
  
- =add-file-local-variable= : Add local variable to the file
  add전에 mode를 먼저 셋해야할수 있음
- =delete-file-local-variable= :파일에 있는 변수 삭제
- =copy-file-locals-to-dir-locals=
  :  파일에 있는걸 디렉토리 쪽으로 복사
- =copy-dir-locals-to-file-locals=
  :  디렉토리 있는걸 파일로 복사
- =projectile-edit-dir-locals=

Variables:
=safe-local-variable-values=
=safe-local-eval-forms
=enable-local-variable=
- t 하면 add-file-local-variable 할때 safe하지 않으면 물어봄
- nil하면 안하는거고
- safe하면 safe한것만 됨
- all 무조건 로드
=enable-local-eval=
- maybe하면 기본 프롬프트
- t하면 자동 eval
- nil하면 스킵

* Org Mode
** 기본 사용법
- head
  *는 첫째 head , =C-<return>= 새로운 아이템을 추가함 동일레벨로, =M-<ret>= 도 동일 대신위
  **는 둘째 head, =M-up= 같은거는 동일레벨에서 위치 위아래로 바꿈,
                 =S-M-up= 하면 레벨 관계없이 한줄단위 변경가능
  S-tab하면 head 아래 보이는걸 줄여주기도 함
- link
  org-insert-link, 글자선택후 =C-c C-l= 하면 하이퍼링크 삽입가능; =C-c C-o= 하면 현재 커서 링크를 열게됨

- table
  table |--|--|--| esc하고 =M-<ret>= 하면 가로줄 생김, =tab= 은 정렬기능 
  
- list
  list 는 - item, 1. item 하고 입력하면 되고 뒤에서 =M-<ret>= 하면 바로 아래줄 아이템 추가
  S-> 하면 리스트 모양 바뀜 - 1) 등등

- check list
 check list [ ]  안에 X넣어도 되고 =C-c C-x C-b= C를 홀드 하고 cxb하면 됨
              =S-M-<ret>= 하면 체크박스 추가됨 (list에서 이키는 체크박스 추가)딴데서는 todo로 사용됨
- souce block
  #+begin_src python :results output
  #이렇게 하면 print한 결과가 result에 나옴
  #+end_src


- TODO
 TODO는 heading에서 todo입력하면 됨 =C-c C-t= 하면 done으로 바뀜 S-방향키 해도 됨

- *bold*, /test/, _underlined_, =verbatim= and ~code~
  * b *, / i / , _ u _ , = v =, ~ c ~
#+BEGIN_SRC emacs-lisp :results output
(setq org-emphasis-alist
	'(("*" (bold :foreground "red"))
      ("_" underline)
	  ("/" italic)
	  ("=" org-verbatim verbatim)
	  ("~" org-code verbatim)
	  ("+" (:strike-through t))))

 #+END_SRC

 
 C-x X h h : 하이라이트 하기
 C-x X u r : 하이라이트 지우기
 #+BEGIN_SRC emacs-lisp :results output
   (use-package highlight
     :ensure t)
 #+END_SRC

** Org 단축키
- org-agenda org-agenda-list
- org-schedule삽입 =C-c C-s= shift누르고 방향키 한담에 <ret>
- org-todo 상태변경 =C-c C-t=
- org-deadline =C-c C-d=
-  org-deadline-warning-days로 agenda에 나타나는 날자를 정할수 있음
- org-timestamp =C-c .=
- repeated tasks~ every one day, 등등 알람을 계속주는것
-  +1y를 붙이면  +2d +1d등등 하면 됨<2022-02-07 월+1d>
- org-wild-notifer 는 os와 상관없이 노티를 날려주는 패키지
- task state를 줘서 todo 리스트를 관리할수 있음
- counsel-org-tag 한담에 tag를 추가할 수 잇음 M-<ret>해서 여러개 추가나 선택도 가능
- org-agenda-custom-commands, org-tag-alist같은 패키지들로 태그 관리가능.
- org-set-effort 
- org-set-properties effort 5 days =C-c C-x p=
  
** 기본 설정

#+begin_src emacs-lisp
  (defun efs/org-mode-setup()
    (org-indent-mode)
    ;(variable-pitch-mode 1)
    ;(auto-fill-mode 0)
    (visual-line-mode 1))
    ;(setq evil-auto-indent nil))
                                          ;(use-package toc-org)
#+end_src

** Org custom 설정

#+begin_src emacs-lisp
  (use-package org
    :hook (org-mode . efs/org-mode-setup) ;훅을 쓰는 이유는 org buffer시작할때마다 위에설정 호출해서 그버퍼는 변수상태로 셋업하기 위함.
    :config
    (setq org-ellipsis " ▾" ; S-tab하면 ... 나오는걸 이걸로 바꾸기 위함
          org-hide-emphasis-markers t) ;bold link등 */같은거 안보이게
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    ;todo의 종류들을 추가하는 것으로 |기준으로 active냐 종료상태를 좌우로 나뉨
    (setq org-todo-keywords
          '((sequenct "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
            (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVITE(a)" "REVIEW(v)" "WAIT(w@/!)" "|" "COMPLETED(c)" "CANC(k@)")))
    (setq org-refile-targets
          '((nil :maxlevel . 1)
           (org-agenda-files :maxlevel . 1))))

  (if (eq system-type 'darwin)
      (setq org-agenda-files ; agenda에서 관리할 파일 리스트로 ""다음줄에 ""또넣어도됨
        '("~/Notes/agenda.org" ;macos
          "~/.emacs.d/README.org" ;linux
          "~/workspace/org/tasks.org"))) ; '요거 하나는 뒤에가 리스트라는 의미로 펑션콜이 아님을 의미
  (setq org-startup-with-inline-images t) ; org에서 그림파일 항상 보이게
  
  ;(advice-add 'org-refile :after 'org-save-all-org-buffers)
  ;이렇게 하면 org-refile실행시 바로 org-save-all-org-buffers가 실행이됨
#+end_src

#+RESULTS:
: ((nil :maxlevel . 1) (org-agenda-files :maxlevel . 1))

** hook
#+begin_src emacs-lisp
  ;스크린 캡처
  (add-hook 'org-mode-hook
    (lambda ()
      (defun cam ()
        (interactive)
        (if buffer-file-name
          (progn
	    (message "Waiting for region selection with mouse ...")
	    (make-directory "./images/" t)
	    (let ((filename
	           (concat "./images/"
	                   (file-name-nondirectory buffer-file-name)
	          	 "_"
	          	 (format-time-string "%Y%m%d_%H%M%S")
	          	 ".png")))
	      (if (executable-find "scrot")
	          (call-process "scrot" nil nil nil "-s" filename)
	          (call-process "screencapture" nil nil nil "-s" filename))
	      (insert (concat "[[" filename "]]"))
	      (org-display-inline-images t t)
	    )
	    (message "File created and linked ...")
          )
          (message "You're in a not saved buffer! Save it first!")
        )
      )
    )
  )
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

** Head 를 좀더 멋지게 수정

#+begin_src emacs-lisp
  ;head마다 다른 사이즈
  (require 'org-faces)
  (dolist (face '((org-level-1 . 1.1)
                  (org-level-2 . 1.07)
                  (org-level-3 . 1.05)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.0)
                  (org-level-6 . 1.0)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    (set-face-attribute (car face) nil :font "D2Coding" :weight 'medium :height (cdr face)))
  ;head마다 끝에만 보이게 하되 글자를 다음처럼 바꾸라
  (use-package  org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("*" "○" "●" "○" "●" "○" "●")))

  ; list hyphen 을 dot으로 수정
  ; 정규식으로 이걸 만듬
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                              (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

** Org Mode 가운데 정렬

#+begin_src emacs-lisp
;;visual fill mode는 org mode가 왼쪽에 치우친걸 상황을 바꿈
;set margins mode
;(defun efs/org-mode-visual-fill ()
;  (setq visual-fill-column-width 110
;        visual-fill-column-center-text t)
;  (visual-fill-column-mode 1))
;(use-package visual-fill-column
;  :hook (org-mode . efs/org-mode-visual-fill))
#+end_src

** Org Capture
- M-x org-capture 해서 새로운 org file만들때 기본 템플릿을 정의하는것


#+begin_src emacs-lisp
  ;org-capture
  ;org-capture-templates
  (setq org-capture-templates
    `(("t" "Tasks / Projects")
      ;("tt" "Task" entry (file+olp "~/workspace/org/tasks.org" "Inbox") ; macos
      ("tt" "Task" entry (file+olp "~/.emacs.d/README.org" "Inbox") ;linux
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

      ("j" "Journal Entries")
      ("jj" "Journal" entry
           (file+olp+datetree "~/.emacs.d/README.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
           ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
           :clock-in :clock-resume
           :empty-lines 1)
      ;("jm" "Meeting" entry
      ;     (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
      ;     "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
      ;     :clock-in :clock-resume
      ;     :empty-lines 1)

      ;("w" "Workflows")
      ;("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
      ;     "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

      ;("m" "Metrics Capture")
      ;("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
      ; "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)
      ))

  (define-key global-map (kbd "C-c j")
    (lambda () (interactive) (org-capture nil "jj")))

#+end_src

** Org Alert
- install 할때 org-plus-contrib가 있는지 보고 설치함
- =DBUS ERROR=
: eval &(dbus-launch)
: export DBUS_SESSIN_BUS_ADDRESS
: emacs

- =org-notify-add= 확인
#+begin_src emacs-lisp
  (use-package org
  :ensure org-plus-contrib)

  (use-package org-notify
  :ensure nil
  :after org
  :config
  (org-notify-start)
  (org-notify-add
   'default
   '(:time "10m" :period "5s" :duration 100 :actions -notify)
   '(:time "7m" :period "5s" :duration 50 :actions -notify/window))
  (org-notify-add
   'reminder
   '(:time "10m" :period "5s" :duration 100 :actions -notify)))
#+end_src

** Org Babel 
*** 코드블럭 실행
- M-x org-babel-execute-src-block
- 단축키 블럭에 가서 C-c C-c

- org-confirm-babel-evaluate nil 하면 실행시 팝업 띄울지 아니오로

- file local value를 아래형태로 셋해서 저장할때 실행도 가능
- (add-hook 'after-save-hook #'org-babel-execute-buffer t t)
  -> t t가 이 버퍼만 셋하겠다는 의미?

- #+begin_src python :results output
- #이렇게 하면 print한 결과가 result에 나옴
- #+end_src

- #+begin_src python :results value
- #이렇게 하면 return한 결과가 result에 나옴
- #+end_src

*변수 넘기는법*
- #+name: first_block
- #+BEGIN_SRC python
- x = 12
- return x
- #+END_SRC

- #+BEGIN_RC python :var x=first_block
- return int(x)+1
- #+END_SRC

*** Tangle
:LOGBOOK:
- Note taken on [2022-09-13 화 00:13]
:END:
- #+PROPERTY: header-args:emacs-lisp :tangle ./init-new.el하면 모든 내용이 저 파일로 옮겨짐
- org-babel-tangle C-c C-v t 블록을 딴 파일에 저장.
  이걸 이용해서 emacs를 시작하도록 하면 됨.
- #+begin_src python :tangle ./newpython.py
  org-babel-tangle-file "파일명" 으로 자동으로 해당파일을 tangle하도록 할 수 있음

  ;이 파일을 저장하면 자동으로 tangle해서 저장하도록 하고싶다면
- #+PROPERTY: header-args:emacs-lisp :tangle ./init-new.el
  
#+begin_src emacs-lisp
  ; org-babel에서 사용할수 있는 언어 등록
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (python . t)))
  
  
  (setq org-confirm-babel-evaluate nil) ;;실행할지 묻는거 끄기
  (setq org-babel-python-command "python3") ;;python3써라
  
  ;;<py 입력후 탭 하면 블록이 생김
  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  
  (if (eq system-type 'darwin)
  ;이 파일을 저장하면 자동으로 tangle해서 저장하도록 하고싶다면
      (defun efs/org-babel-tangle-config ()
        (when (string-equal (buffer-file-name)
                        (expand-file-name "/Users/eddie/.emacs.d/init.org"))
          (let ((org-confirm-babel-evaluate nil))
            (org-babel-tangle)))))
  (if (eq system-type 'gnu/linux)
  ;이 파일을 저장하면 자동으로 tangle해서 저장하도록 하고싶다면
      (defun efs/org-babel-tangle-config ()
        (when (string-equal (file-name-directory (buffer-file-name))
                        (expand-file-name "~/.emacs.d/"))
          (let ((org-confirm-babel-evaluate nil))
            (org-babel-tangle)))))
   (add-hook 'org-mode-hook (lambda ()(add-hook 'after-save-hook #'efs/org-babel-tangle-config)))
#+end_src

- output파일에 폴더 생성 원할시 =:mkdirp yes= 를 추가
  #+begin_src emacs-lisp
  ;(push '("confi-unix" . confi-unix) org-src-lang-mode)
  #+end_src

  #+begin_src conf :tangle ~/dummy.conf :mkdirp yes
	;value = 42

  #+end_src

*** Noweb
- 블럭의 결과를 다른 블럭에 쓰거나 할때 씀 json이나 txt파일들을 쓸때도 씀.
- :noweb yes하면 값을 가져올 수 있음

#+NAME: the-value
  #+begin_src emacs-lisp
;(+ 55 100)
  #+end_src

  #+RESULTS: the-value
  : 155


#+begin_src python :noweb yes :results output
	print(<<the-value()>>)
#+end_src

#+RESULTS:
: 155

** Org Mode website
- build-site.el
- org에 기본적으로 내제된 ox-publish를 임포트 후, 메시지 만들기
- M-x describie-va.. 한담에 org-publish-project-alist검색하면 프로젝트 설정하는 설명 나옴
  : org-html하면 많이 나옴
- content라는 폴더에 index.org 파일을 두면 해당 파일이 기본이 됨
- www.simplecss.org 등 참고
- C-c C-l Org-insert-link로 링크 만들기 ./emacs.org
#+BEGIN_SRC emacs-lisp
  ;;코드블락을 지원하기 위해 htmlize를 설치
  (require 'package)
  (setq package-user-dir (expand-file-name "./.packages"))
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
  (package-install 'htmlize)

  ;;여기서 시작
  (require 'ox-publish)

  (setq org-html-validation-link nil ;;html마지막에 validate뜨는거 막기
        org-html-head-include-scripts nil ;;use our own scripts
        org-html-head-include-default-style nil ;;use our own styles
        org-html-head "<link rel=\"stylesheet\" href=\"https://cdn.simplecss.org/simple.min.css\" />")


  ;;define the publishing project list가 두개인건 첫번재는 전체 프로젝트 그룹, 두번째는 그중 하나 프로젝트
  (setq org-publish-project-alist
        (list
         (list "my-org-site"
               :recursive t ;;sub folder들도 찾아보게함
               :base-directory "./content"
               :publishing-directory "./pubilsh"
               :publishing-function 'org-html-publish-to-html
	           :with-author nil    ;; don't include author name
	           :with-creator nil     ;; include Emacs and Org versions in folder
	           :with-toc nil         ;; include a table of contents
	           :section-numbers nil ;; Don't include section number
	           :time-stamp-file nil ;; Don't include time stamp in file
	     )))
  ;; Generate the site output
  (org-publish-all t) ;;t는 캐시파일쓰지말고 다시 생성하라는 뜻임
  (message "Build complete")
#+END_SRC

- build.sh
- emacs lisp 스크립트를 돌릴 쉘파일 필요함
- -Q 를 넣어야 기본 컨피그를 로드하지 않음
- chmod +x build.sh
#+BEGIN_SRC sh
  #!/bin/sh
  emacs -Q --script build-site.el
#+END_SRC

- website를 호스트해서 브라우저에서 볼수있게 해줌
- M-x httpd-serve-directory 명령으로 사이트 띄우자
- 기본적으로 8080폴더를 쓰니 변화를 필요로하면 httpd-port변수를 셋하면 됨
#+BEGIN_SRC emacs-lisp
  (use-package simple-httpd
    :ensure t)

#+END_SRC




** Org Roam
*** install
- v2버전의 org roam부터 sqlite가 필요함
- sqlite가 설치되었는지 확인하는 변수 *org-roam--sqlite-available-p*
  이걸 describe value C-h v 로 확인하자
- 몇자 입력하고 M-x completion-at-point 입력하면 roam: link 가 생성됨

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t) ;roam v1쓸경우 팝업창 뜨는걸 방지
    :custom
    (org-roam-directory "~/Notes")
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain
        "%?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
        :unnarrowed t)
       ("b" "book notes" plain
          (file "~/.emacs.d/Templates/BookNote.org")
          :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
          :unnarrowed t)
       ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: Project")
        :unnarrowed t)
       ))
    (org-roam-dailies-capture-templates
     '(("d" "default" entry "* %?  =%<<%I:%M %p>>=\n"
        :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
    :bind (("C-c n b" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n l" . org-id-get-create)
           ("C-c n g" . org-roam-graph)
           :map org-mode-map
           ("C-M-i" . completion-at-point)
           :map org-roam-dailies-map
           ("Y" . org-roam-dailies-capture-yesterday)
           ("T" . org-roam-dailies-capture-tomorrow)
           ("g" . org-roam-dailies-goto-date)
           ("G" . org-roam-dailies-capture-date))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :config
    (require 'org-roam-dailies)
    (org-roam-setup)
    (org-roam-db-autosync-mode))

  ;(setq org-roam-dailies-directory "journal/") ;daily가 아닌 폴더를 하위폴더로 쓸 경우 지정필요

  ;;필요한 함수 셋업
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (push arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  ;org-roam-node-list가 없어서 주석처리
  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (my/org-roam-list-notes-by-tag "Project")))

  ;; Build the agenda list the first time for the session
  (my/org-roam-refresh-agenda-list)

  ;; Bind this to C-c n I ; 첫 캡처템플릿으로 만들기만하고 현 buffer에 머무르기
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))


  ;; 특정 tag의 note list를 선택하기
  (defun my/org-roam-project-finalize-hook ()
    ;"Adds the captured project file to `org-agenda-files' if the capture was not aborted."
    ;; Remove the hook since it was added temporarily
    (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Add project file to the agenda list if the capture was confirmed
    (unless org-note-abort
      (with-current-buffer (org-capture-get :buffer)
        (add-to-list 'org-agenda-files (buffer-file-name)))))

  (defun my/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (my/org-roam-filter-by-tag "Project")
     :templates
     '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
        :unnarrowed t))))

  ;;지금 쓰는것과 상관없는거 떠오를때 inbox.org에 임시저장하기 위한것
  (defun my/org-roam-capture-inbox ()
    (interactive)
    (org-roam-capture- :node (org-roam-node-create)
                       :templates '(("i" "inbox" plain "* %?"
                                    :if-new (file+head "Inbox.org" "#+title: Inbox\n")))))


  ;capture a task directly into a specific project
  (defun my/org-roam-capture-task ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Capture the new task, creating the project file if necessary
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (my/org-roam-filter-by-tag "Project"))
                       :templates '(("p" "project" plain "* TODO %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Tasks"))))))
  (defun my/org-roam-copy-todo-to-today ()
    (interactive)
    (let ((org-refile-keep t) ;; Set this to nil to delete the original!
          (org-roam-dailies-capture-templates
            '(("t" "tasks" entry "%?"
               :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Tasks")))))
          (org-after-refile-insert-hook #'save-buffer)
          today-file
          pos)
      (save-window-excursion
        (org-roam-dailies--capture (current-time) t)
        (setq today-file (buffer-file-name))
        (setq pos (point)))

      ;; Only refile if the target file is different than the current file
      (unless (equal (file-truename today-file)
                     (file-truename (buffer-file-name)))
        (org-refile nil nil (list "Tasks" today-file nil pos)))))

  (add-to-list 'org-after-todo-state-change-hook
               (lambda ()
                 (when (equal org-state "DONE")
                   (my/org-roam-copy-todo-to-today)))) 
  (global-set-key (kbd "C-c n t") #'my/org-roam-capture-task)
  (global-set-key (kbd "C-c n T") #'my/org-roam-capture-inbox)
  (global-set-key (kbd "C-c n p") #'my/org-roam-find-project)
  (setq org-clock-sound "~/.emacs.d/isound.wav")

#+END_SRC

*** usage
- zettelcasten 방법을 사용
- *C-c n f* : 찾기 혹은 node 만들기
   capture buffer가 org node를 위해 만들어짐 다양한 템플릿을 지원하기 위해
- C-c C-c : 이 capture를 file에 저장
- C-c n i : 다른 롬 파일 링크 생성, 없는걸 만들면서 링크 생성할수도 있음
- *C-c n I* : 다른 롬 파일 링크 생성, 없는걸 만들면서 링크 생성하고 현버퍼에 있기
- *C-c n T* : 다른 롬 파일 링크 생성, 없는걸 만들면서 현버퍼에 있기
- C-M-i : title앞부분 입력후 이 키 입력시 링크가 바로 생성됨
- C-c n l : 파일 중간 부분 링크 생성 -> 헤딩 노드만 생성 M-x org-id-get-create 
- node에 alias추가 가능 : 헤더에 가서 M-x org-roam-alias-add 하면되고 여러개 추가도 가능
- C-c n b : backlink 나를 링크한곳 모아 보기 * org-roam * 이라는 이름의 버퍼에서 보여줌
- [[https://www.youtube.com/watch?v=YxgA5z2R08I][Capturing Youtube]]
- [[https://youtu.be/3-sLBaJAtew][Org Roam daily]] : *C-c n d n* : 새폴더 만들기
                   *C-c n d d* : 오늘 모은거 다보기
                   *C-c n d T* : 내일꺼 작성하기
                   *C-c n d Y* : 어제꺼 작성하기
                   *C-c n d G* : 특정일꺼 작성하기
                   *C-c n d t* : 내일 모은거 다보기
                   *C-c n d y* : 어제 모은거 다보기
                   *C-c n d G* : 특정일 모은거 다보기
                   *C-c n d b* : 현재파일 이전날 보기
                   *C-c n d f* : 현재파일 다음날 보기

* Terminal
** vterm
#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000)))
  (if (eq system-type 'gnu/linux)
  (use-package vterm
    :commands vterm
    :load-path "~/.emacs.d/emacs-libvterm"
    :config
    (setq vterm-max-scrollback 10000)))
  (add-hook 'vterm-mode-hook 'evil-emacs-state)
#+end_src
** eshell
#+begin_src emacs-lisp
  (defun efs/configure-eshell()
    ;;save command history
    (add-hock 'eshell-pre-command-hook 'eshell-save-some-history)
    ;; truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffers)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)
    (setq eshell-history-size 10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt)

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config
    (eshell-git-prompt-use-theme 'powerline))
  
#+end_src

* 각종 팁
 - system-type변수에는 현재 환경이 windows인지 등이 나옴
 - package-refresh-contents : 패키지 없다고 할때 해주면 됨
   
* Windows and Frames

- A "window" is a region within an Emacs frame that shows a particular buffer
- A "frame" is an Emacs program window at the level of your OS or desktop environment which can hold multiple windows
- Multiple windows can show the same buffer, but with different scroll, selection, etc

Check out the Emacs manual entry for [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows.html#Windows][Multiple Windows]]

* Basic Window Operations

Each item lists the default Emacs binding followed by the evil-mode binding.  Note that many of the evil-mode bindings also allow you to use Ctrl with the second key in the sequence!

| Command                             | Key   | Description                            |
|-------------------------------------+-------+----------------------------------------|
| =delete-window=                       | ~C-x 0~ | Close the current window               |
| =delete-other-windows=                | ~C-x 1~ | Close all other windows                |
| =split-window-below=                  | ~C-x 2~ | Split the current window horizonally   |
| =split-window-right=                  | ~C-x 3~ | Split the current window vertically    |
| =shrink-window-horizontally=          | ~C-x {~ | Make the window smaller horizontally   |
| =enlarge-window-horizontally=         | ~C-x }~ | Make the window bigger horizontally    |
| =shrink-window=                       | None! | Shrink the window vertically           |
| =shrink-window-if-larger-than-buffer= | ~C-x -~ | Shrink the window vertically to buffer |
| =balance-windows=                     | ~C-x +~ | Balance the sizes of all windows       |

*TIP*: You can use ~C-u~ (=universal-argument=) and a numeric prefix before running the =shrink= and =enlarge= commands to dictate the mount by which the window is resized.

** evil-mode alternatives

| Command                | Key        | Description                             |
|------------------------+------------+-----------------------------------------|
| =evil-window-delete=     | ~C-w C-c~    | Close the current window                |
| =delete-other-windows=   | ~C-w C-o~    | Close all other windows                 |
| =evil-window-split=      | ~C-w C-s~    | Split the current window horizontally   |
| =evil-window-vsplit=     | ~C-w C-v~    | Split the current window vertically     |
| =evil-window-set-width=  | ~C-w (pipe)~ | Use numeric prefix to set window width  |
| =evil-window-set-height= | ~C-w _~      | Use numeric prefix to set window height |
| =balance-windows=        | ~C-w =~      | Balance the sizes of all windows        |

*TIP*: You can use a numeric argument before running =evil-window-set-width= and =evil-window-set-height= to specify the desired size of the window.

** "Other window" operations

| Command                  | Keys      | Description                                      |
|--------------------------+-----------+--------------------------------------------------|
| =other-window=             | ~C-x o~     | Select the next visible window                   |
| =find-file-other-window=   | ~C-x 4 f~   | Open a file in another window                    |
| =dired-other-window=       | ~C-x 4 d~   | Open Dired in another window                     |
| =dired-jump-other-window=  | ~C-x 4 C-j~ | Open Dired in another window at location of file |
| =scroll-other-window=      | ~M-pgdn~    | Scroll the other window down without focusing it |
| =scroll-other-window-down= | ~M-pgup~    | Scroll the other window up without focusing it   |

*** evil-mode alternatives

| Command           | Keys    | Description                        |
|-------------------+---------+------------------------------------|
| =evil-window-next=  | ~C-w C-w~ | Select the next visible window     |
| =evil-window-prev=  | ~C-w W~   | Select the previous visible window |
| =ffap-other-window= | ~C-w C-f~ | Open a file in another window      |

**** More =other-window= commands

Learn about more =other-window= commands:

- Check out the ~C-x 4~ prefix with =which-key=!
- Also, use =counsel-M-x= and search for any commands with =other-window= in the name!

** Defaulting to vertical splits

You can default to vertical splits for "other windows" with the following config:

#+begin_src emacs-lisp

  (setq split-height-threshold nil)
  (setq split-width-threshold 0)

#+end_src

More information about controlling [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Choosing-Window-Options.html][how buffers are displayed]] in the Emacs manual.

** Windmove for moving between windows

Windmove comes with Emacs, but is missing some features in Emacs 26.

- =windmove-up/down/left/right= - Focus the window next to the current in the specified direction
- =windmove-swap-states-up/down/left/right= - "Move" the current buffer to the window in the specified direction

*** evil-mode equivalents

evil-mode provides its own functions for moving between windows:

- =evil-window-left= - ~C-w h~
- =evil-window-right= - ~C-w l~
- =evil-window-up= - ~C-w k~
- =evil-window-down= - ~C-w j~

** buffer-move or moving buffers between windows

Use =buffer-move= for a more general solution:
buf-move한담에 방향키로 이동이 젤편

- =buf-move=: Turn on a mode where you can move the current buffer around with arrow keys, any other key finishes it
- =buf-move-left=
- =buf-move-right=
- =buf-move-up=
- =buf-move-down=

#+begin_src emacs-lisp

  (use-package buffer-move)

#+end_src

* winner-mode

=winner-mode= provides useful functions for undoing and redoing window configurations:

- =winner-undo= (~C-c left~ or ~C-w u~ bound below)
- =winner-redo= (~C-c right~ or ~C-w U~ bound below)

#+begin_src emacs-lisp

  (use-package winner-mode
    :ensure nil
    :bind (:map evil-window-map
           ("u" . winner-undo)
           ("U" . winner-redo))
    :config
    (winner-mode))

#+end_src

** Packages for moving between windows
*** ace-window
;윈도우 빠르게 이동, 윈도 마다 번호 매겨서 그 번호 누름 되게끔함
[[https://github.com/abo-abo/ace-window][ace-window]] makes it easy to jump between visible windows in your Emacs frame, just run the =ace-window= command and press the number displayed in the upper left corner of the window you want to switch to.  It also enables you to swap, delete, and move windows using similar functionality.

#+begin_src emacs-lisp

  (use-package ace-window)

#+end_src

Tip from *Cedrif Daf*: Set =aw-keys= to home-row keys for more convenience:

#+begin_src emacs-lisp

(setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))

#+end_src

*** winum-mode
;현재 윈도에서 숫자로 이동 =C-x w 1=
This mode shows numbers in your windows' mode lines to tell you what keys you can press after using the key binding =C-x w=.  Check out the [[https://github.com/deb0ch/emacs-winum][winum-mode]] page for more useful tips!

#+begin_src emacs-lisp
  (use-package winum
    :config
    (winum-mode))
#+end_src


#+title: Unlock the Power of the Daemon with emacsclient

* What is the Emacs daemon?

Emacs can be run in a server mode:

- Pay Emacs startup cost only once per boot/login!
- Buffers persist across Emacs frames, can close Emacs window and reopen later
- Execute arbitrary commands and expressions from the command line

Manual:
https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server

** Starting the daemon

The easiest way to get started is to use the following command inside of a running Emacs session

#+begin_src emacs-lisp

  ;; Enable server mode (daemon) for this Emacs session
  ;(server-start)

#+end_src

However, this is *very* different in practice than running Emacs as a real daemon!  We'll show why in a bit.

#+begin_src sh

  emacs --daemon

  # OR run as a foreground process (can be helpful to diagnose errors)

  emacs --fg-daemon

#+end_src

You can also have independent daemons:

#+begin_src sh

  # Start daemon named 'my-other-daemon'
  emacs --daemon=my-other-daemon

#+end_src

** Trying it out

Let's try running the Emacs daemon and see how it differs from running Emacs normally.

Run Emacs normally first to get a sense of the startup time.

#+begin_src sh

  emacs

#+end_src

Now run it as a daemon and notice how fast =emacsclient= creates a new frame:

#+begin_src sh

  emacs --fg-daemon

  emacsclient -c

#+end_src

Notice anything different about the UI?

*TIP*: You can find the list of active daemon names (sockets) by looking in the directory stored in the =server-socket-dir= variable in Emacs!

*** Killing the Emacs daemon

To kill the Emacs daemon, send the =(kill-emacs)= command to it:

#+begin_src sh

  emacsclient -e "(kill-emacs)"

#+end_src

** Using emacsclient

Manual:
https://www.gnu.org/software/emacs/manual/html_node/emacs/emacsclient-Options.html#emacsclient-Options

*** Important arguments

- ~-c~ / ~--create-frame~ - Create a new frame (don't pass this if you want to reuse the same open frame)
- ~-n~ / ~--no-wait~ - Don't wait for the Emacs frame to close
- ~-e~ / ~--eval~ - Evaluate an Emacs Lisp expression within the daemon
- ~-u~ / ~--suppress-output~ - Suppress output from Emacs (useful when running in a script)
- ~-s~ / ~--socket-name=name~ - Use a named daemon (=emacs --daemon=name=)
- ~-a~ / ~--alternate-editor=name~ - If Emacs daemon isn't running, use this command instead
- ~filename~ - Open a file in the current frame (or a new one if ~-c~ is passed)

*** Opening files from the command line

To open a new Emacs frame for a file without waiting for emacsclient to exit:

#+begin_src sh

  emacsclient -c -n ~/.emacs.d/Emacs.org

#+end_src

Set =EDITOR= to =emacsclient= in your shell's profile (=.bash_profile=, =.zsh_profile=, etc)

#+begin_src sh

  export EDITOR="emacsclient -c -a emacs"

#+end_src

Test this by using =git commit= (use ~C-x #~ to confirm your edit and close the frame!)

*** Evaluating expressions

This makes it easy to integrate other programs with Emacs!

#+begin_src sh

  emacsclient -e "(buffer-name)"

#+end_src

You can also run interactive commands to cause something to happen in the active Emacs frame:

#+begin_src sh

emacsclient -e "(counsel-switch-buffer)"

emacsclient -e "(read-string \"Enter a string: \")"

#+end_src

*** Automating Emacs in shell scripts

Example: [[file:~/.dotfiles/.bin/sync-dotfiles::emacsclient -u -e "(org-save-all-org-buffers)" -a "echo 'Emacs is not currently running'"][My =sync-dotfiles= script]] ([[https://github.com/daviwil/dotfiles/blob/master/.bin/sync-dotfiles#L15][Web]])

#+begin_src sh

  emacsclient -u -e "(org-save-all-org-buffers)" -a "echo 'Emacs is not currently running'"

#+end_src

*** Offloading tasks to another daemon

I don't necessarily recommend this approach, but it is possible!

#+begin_src emacs-lisp

  ;emacs --daemon=worker
  ;emacsclient -f worker -u -e "(org-babel-tangle-file \"~/.emacs.d/Emacs.org\")"

#+end_src

I'd recommend checking out the =async= package if you want to do things like this, though:

https://github.com/jwiegley/emacs-async/

We'll cover it in another video.


*** Running Emacs at Startup

Emacs comes with a =systemd= unit file:

#+begin_src sh

  sudo systemctl --user enable emacs

#+end_src

If you're allergic to =systemd= (or just want another way to run at login), you can possibly add it to the startup configuration for your desktop environment, profile script, etc.
* json Mode

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t)
#+END_SRC

